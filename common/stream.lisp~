(defvar the-empty-stream '())

(defun stream-null? (s)
  (eql nil s))

(defun force (delayed-object)
  (funcall delayed-object))

(defun stream-car (s)
  (car s))

(defun stream-cdr (s)
  (force (cdr s)))

(defmacro cons-stream (a b)
  `(cons ,a (delay ,b)))
;please notice this is really an efficiency problem
;(defmacro delay (x)
 ; `(lambda () ,x))
(defmacro delay (expr)`(memo-proc (lambda () ,expr)))

(defun memo-proc (proc)
  (let ((already-run? nil) (result nil))
    (lambda ()
      (if (not already-run?)
        (progn
          (setf result (funcall proc))
          (setf already-run? t)
          result)
        result))))

(defun stream-ref (s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

(defun stream-filter (pred s)
  (cond ((stream-null? s) the-empty-stream)
	((funcall pred (stream-car s))
	 (cons-stream (stream-car s)
		      (stream-filter pred (stream-cdr s))))
	(t (stream-filter pred (stream-cdr s)))))
(defun stream-enumerate-interval (m n)
  (if (> m n)
      the-empty-stream
      (cons-stream m 
		   (stream-enumerate-interval (+ 1 m) n))))
(defun integer-from (n)
  (cons-stream n
	       (integer-from (+ n 1))))
