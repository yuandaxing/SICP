#lang scheme
(define a 1)
(define b 2)
;(list 'a 'b)
;(list 'a b)
;(car '(a b c))
;(cdr '(a b c))

;'()

(define (memq item l)
  (cond ((null? l) false)
        ((eq? item (car l)) l)
        (else (memq item (cdr l)))))

;(memq 'apple '(pear banana prune))

;(memq 'apple '(x (apple sauce) y apple pear))

(define (atom? x)
  (not (pair? x)))
(define (equal? l1 l2)
  (cond ((and (null? l1) (null? l2)) true)
        ((or (null? l1) (null? l2)) false)
        ((and (pair? (car l1))
              (pair? (car l2)))
         (and (equal? (car l1) (car l2))
              (equal? (cdr l1) (cdr l2))))
        ((and (atom? (car l1)) (atom? (car l2)))
         (and (eq? (car l1) (car l2)) (equal? (cdr l1) (cdr l2))))
        (else false)))

;(equal? '(this is a (a s) list) '(this is a (a s) list))
(define (exponentiation? exp) 
  (and (pair? exp) (eq? (car exp) '**)))
(define (base exp)
  (cadr exp))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
         (error "unknown expression type -- DERIV" exp))))

(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
;(define (make-sum a1 a2) (list '+ a1 a2))
;(define (make-product m1 m2) (list '* m1 m2))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (product? x)
  (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p) (caddr p))

;(deriv '(+ x 3) 'x)
;(deriv '(* x y) 'x)
;(deriv '(* (* x y) (+ x 3)) 'x)
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
(deriv '(* (* x y) (+ x 3)) 'x)

;2.3.3
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((eq? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
(define set1 (list 1 2 3 4 5))
(display (element-of-set? 6 set1))
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
(newline)
(display (adjoin-set 6 set1))
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)        
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
(newline)
(define s2 (list 2 4 7 9))
(display (intersection-set set1 s2))
(define (union-set  s1 s2)
  (cond ((null? s1) s2)
        ((element-of-set? (car s1) s2)
         (union-set (cdr s1) s2))
        (else (cons (car s1) 
                    (union-set (cdr s1) s2)))))
(newline)
(display (union-set set1 s2))




